 类加载的时机

1.遇到new.getstatic.putstatic.invokestatic

2.使用java.lang.reflect反射调用

3.初始化一个类，发现父类未初始化，先初始化父类

4.当启动时，初始化主类（main）

类加载的过程

1.类加载：

1）.通过一个类的全限定名来获取此类的二进制字节码

2）.将字节流所代表的静态存储结构转化为方法区的运行数据结构

3）.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

2.验证

1）.验证到输入的字节流不符合Class文件格式的约束，抛出VerifyError

2）.文件格式验证：是否以魔数开头oxCAFEBABE，常量池的常量中是否有不被支持的常量类型（检查tag）等

3）.元数据验证：这个父类是否继承不允许被继承的类，如果不是抽象类，是否实现了父类或者接口要求实现的所有方法，

4）.字节码验证：保证任意时刻操作数栈的数据类型与指令代码都能配合工作int不会按long类型加载，保证跳转指令不会跳转到方法体以外的字节码指令上。类型转换有效，

3.准备

准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这时候进行内存分配的仅包括类对象（static修饰的），不包括实例对象。public static int value=123,现在初始值为0，只是分配了空间，赋值是putstatic指令在程序被编译后。要在初始化阶段才执行。

4.解析

虚拟机将常量池内的符号引用替换为直接引用的过程，直接引用的目标一定在内存中存在。

1）.类或接口的解析

2）.字段解析   如果成功返回了引用，将进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError

3）.类方法解析 

5.初始化

这里开始真正的执行java程序代码，初始化阶段是执行类构造器<cilnit>（）方法的过程。