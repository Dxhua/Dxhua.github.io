---
layout:     post                    # 使用的布局（不需要改）
title:      Android和Java的基础知识，还是很全面               # 标题 
subtitle:   Android和java面试基础 #副标题
date:       2018-07-10              # 时间
author:     Dxhua                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - android
    - Java
    - 面试
---

# Android基础 #
## 关于Activity ##
### 关于栈： ###
    每一个APP都有一个默认的task，以packageName命名，activity按照启动的顺序存在这个栈中。

    也可以在AndroidMainfest.xml中设置一个属性叫taskAffinity来自定义这个栈。

### 关于生命周期 ###
![生命周期](https://i.imgur.com/YsuQUhz.png)
- 完整的周期从onCreate到onDeatory。
- activity之间来回切换会在onStart和onStop之间。
- app在前台和后台之间切换，会在onResume和onPause之间。

***当activity被系统回收，或者说屏幕旋转了，需要保存一些数据(通过Bundle)***
 ```java
public class MainActivity extends Activity {

    [@Override](/user/Override)
    protected void onCreate(Bundle savedInstanceState) {
        if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
             savedInstanceState.get("Key");
             }
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
   [@Override](/user/Override)
protected void onSaveInstanceState(Bundle outState) {
    // TODO Auto-generated method stub
     //可能被回收内存前保存状态和信息，
       Bundle data = new Bundle();
       data.putString("key", "last words before be kill");
       outState.putAll(data);
    super.onSaveInstanceState(outState);
}
   [@Override](/user/Override)
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    // TODO Auto-generated method stub
       if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
             savedInstanceState.get("Key");
             }
    super.onRestoreInstanceState(savedInstanceState);
}
}
 ```

### 关于启动模式 ###
使用启动模式的两种方法：
1. xml文件中的<activity 下的luanchmode属性
	 ``` java
	android:launchMode="standard"

	还包括：singleTop，singleTask，singleInstance
	 ```
2. 在Intent中添加标志：

	``` java
	Intent i = new Intent(this,ＮewActivity.class);
	i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	startActivity(i);

	还包括：FLAG_ACTIVITY_SINGLE_TOP，FLAG_ACTIVITY_CLEAR_TOP
	```


  ps：模式的解释：
- standard：按顺序一个个叠加
- singleTop=FLAG_ACTIVITY_SINGLE_TOP：如果栈顶有就用栈顶的，不去创建。
- singleTask=FLAG_ACTIVITY_NEW_TASK：在新的栈中创建activity，如果已经有一个栈里面有这个activity，就直接把那个栈放到前台，然后把该activity之前的销毁。其允许其他activity放到这个栈中。
- singleInstance：跟singleTask基本类似，不同的是，此activity所在的栈不允许其他的activity进入。
- FLAG_ACTIVITY_CLEAR_TOP：清除此activity上面的其他activity。
	有问题。。。。

### 关于IntentFilter ###
三大属性：Action、Category、URL（很少有）
  ```java
<intent-filter . . . >
   <action android:name="code android.intent.action.MAIN" />
   <category android:name="code　android.intent.category.LAUNCHER" />
</intent-filter>


Intent i=new Intent();
i.setAction("com.scu.amazing7Action");
  ```
### 设置全屏 ###
设置xml中的主题
或者在代码里面：
```java
// 设置全屏模式
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
 // 去除标题栏
 requestWindowFeature(Window.FEATURE_NO_TITLE);
```

### 设置activity不公开 ###
```java
<activity
．．．．．．
android:exported="false" />

非公开的activity不能设置intentfilter，也不需要设置。
```

### 控制屏幕旋转 ###

如果屏幕旋转了，activity实际上会被销毁，然后再重新加载，可以通过属性设置让它不重新加载
```java
Android:configChanges="orientation|screenSize"
```

当屏幕旋转时会调用：**onConfigurationChanged**，可以重写这个方法做一些事情。


## 关于Service ##
服务是四大组件之一，可以长期运行在后台，没有用户操作的界面，用作播放音乐或者网络传输等等，并且当app被切换到后台以后，其依然可以运行。

### 与Thread的区别 ###
二者并没有关系，thread是一个线程，service是一个组件，服务的默认也是运行于主线程中的，如果是耗时操作，依然需要在服务中创建线程。

### 服务的分类 ###

#### 按运行分类 ####

1. 前台服务：不会被杀死，而且会同时要求设置一个通知栏，用户会知道这个服务的存在。

    使用代码：
    ```java
    Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());

    Intent notificationIntent = new Intent(this,ExampleActivity.class);

    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);

    notification.setLatestEventInfo(this, getText(R.string.notification_title),
            getText(R.string.notification_message), pendingIntent);

    startForeground(ONGOING_NOTIFICATION, notification);

    //取消前台服务
    stopForeground(true)
    //这个方法只是说让服务不是前台了，但是并没有终止此服务。true和false表示是否同时移除状态栏。
    ```


2. 后台服务：正常的服务。

#### 按使用分类 ####

1. 本地服务：用于应用程序内部，通过startService和stopService开启和结束，也可以自己结束，通过service.stopSelf()或者service.stopSelfResult()结束自己。

2. 远程服务：除了被自己调用还可以被其他的应用程序调用，通过context.bindService 和context.unbindService 绑定和解绑。一个服务可以被多个客户端绑定。

### Service 的生命周期 ###
分两种：

![service生命周期](http://ovoxjpcrm.bkt.clouddn.com/25ed3985286db9af31a3650c9d94636d.png)

首先解释一下上图的那些方法：
> - onCreate:服务正在被创建调用。
>
> - onStartCommand:服务正在启动，由startService触发。返回一个int值，决定服务被杀死后的处理方式。可能重建也可能不重建服务。
>
> - onBind:bindService触发。
>
> - onUnbind:unbindService触发。
>
> - onRebind：onUnbind以后又bindService。
>
> - onDestory:服务被销毁。

### 两种方式开服务的区别与结合 ###
start服务：**被创建以后就与调用者无关，调用者死了，它也并不会死。调用者是无法使用服务里面的方法的。** 如果服务被startService很多次，onCreate只会走一次，但是onStart会走很多次，可是Service的实例就只有一个。等到调用者stopService或者服务自己stopSelf,销毁服务。

bind服务：**可以被多个调用者绑定，调用者全部销毁后，服务也会被销毁。调用者是可以使用其中的方法的。** 如果服务被某个activity bindService 很多次，onCreate只会走一次，onStart不会走。

bindService的代码复杂一些，代码如下：
```java
//调用者
public class MainActivity extends Activity {
    /** 是否绑定 */
    boolean mIsBound = false;
    BindService mBoundService;
    [@Override](/user/Override)
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        doBindService();
    }
    /**
     * 实例化ServiceConnection接口的实现类,用于监听服务的状态
     */
    private ServiceConnection conn = new ServiceConnection() {

        [@Override](/user/Override)
        public void onServiceConnected(ComponentName name, IBinder service) {
            BindService mBoundService = ((BindService.MyBinder) service).getService();

        }

        [@Override](/user/Override)
        public void onServiceDisconnected(ComponentName name) {
            mBoundService = null;

        }
    };

    /** 绑定服务 */
    public void doBindService() {
        bindService(new Intent(MainActivity.this, BindService.class), conn,Context.BIND_AUTO_CREATE);
        mIsBound = true;
    }

    /** 解除绑定服务 */
    public void doUnbindService() {
        if (mIsBound) {
            // Detach our existing connection.
            unbindService(conn);
            mIsBound = false;
        }
    }

    [@Override](/user/Override)
    protected void onDestroy() {
        // TODO Auto-generated method stub
        super.onDestroy();

        doUnbindService();
    }
}
  }


  //服务类
  public class BindService extends Service {

       // 实例化MyBinder得到mybinder对象；
      private final MyBinder binder = new MyBinder();

        /**
       * 返回Binder对象。
       */
      [@Override](/user/Override)
      public IBinder onBind(Intent intent) {
          // TODO Auto-generated method stub
          return binder;
      }

       /**
        * 新建内部类MyBinder，继承自Binder(Binder实现IBinder接口),
        * MyBinder提供方法返回BindService实例。
        */
  　　public class MyBinder extends Binder{

          public BindService getService(){
              return BindService.this;
          }
      }


      [@Override](/user/Override)
      public boolean onUnbind(Intent intent) {
          // TODO Auto-generated method stub
          return super.onUnbind(intent);
      }
  }
```

需求：既要求Service不随着Activity的销毁而销毁，又想要调用Service里面的方法。
解决：混合开启（顺序很重要）
1. startService
2. bindService
3. 调用服务方法
4. unbindService
5. stopService


### 其他 ###

- 如果bindService以后屏幕旋转了，那么activity被销毁了，之前与service的绑定也会断开。

- 使用Service需要在manifest里面声明

- 判断Service是否在运行：
```java
private boolean isServiceRunning() {
    ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    {
        if ("com.example.demo.BindService".equals(service.service.getClassName())) 　　{
            return true;
        }
    }
    return false;
}
```

## 关于IntentService ##
代码：
```java
//服务类
public class myIntentService extends IntentService {

    //------------------必须实现-----------------------------

    public myIntentService() {
        super("myIntentService");
        // 注意构造函数参数为空，这个字符串就是worker thread的名字
    }

    [@Override](/user/Override)
    protected void onHandleIntent(Intent intent) {
        //根据Intent的不同进行不同的事务处理
        String taskName = intent.getExtras().getString("taskName");
        switch (taskName) {
        case "task1":
            Log.i("myIntentService", "do task1");
            break;
        case "task2":
            Log.i("myIntentService", "do task2");
            break;
        default:
            break;
        }
    }
  //--------------------用于打印生命周期--------------------
   [@Override](/user/Override)
  public void onCreate() {
        Log.i("myIntentService", "onCreate");
    super.onCreate();
}

    [@Override](/user/Override)
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i("myIntentService", "onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }

    [@Override](/user/Override)
    public void onDestroy() {
        Log.i("myIntentService", "onDestroy");
        super.onDestroy();
    }
}

//调用者
public class MainActivity extends Activity {
    [@Override](/user/Override)
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);

        //同一服务只会开启一个worker thread，在onHandleIntent函数里依次处理intent请求。

        Intent i = new Intent("cn.scu.finch");
        Bundle bundle = new Bundle();
        bundle.putString("taskName", "task1");
        i.putExtras(bundle);
        startService(i);

        Intent i2 = new Intent("cn.scu.finch");
        Bundle bundle2 = new Bundle();
        bundle2.putString("taskName", "task2");
        i2.putExtras(bundle2);
        startService(i2);

        startService(i);  //多次启动
    }
}
```

讲解：
IntentService 就是Service 的加强版，平常如果在Service里面执行耗时操作，需要自己手动的去在异步线程中处理，IntentService 直接给我们处理好了，我们只要处理onHandleIntent方法就好了，减少工作量。

注意：
构造方法一定要按照代码给的那样写
只有一个线程，诶个去处理intent请求，当所有intent请求处理完以后，会自动关闭服务。不用调用stopSelf.

上面的代码的结果：

![IntentService运行结果](http://ovoxjpcrm.bkt.clouddn.com/28985b709878e3f67cedc125d960de9f.png)

它只有一个工作线程，名字就是构造函数的那个字符串，也就是“myIntentService”，我们知道多次开启service，只会调用一次onCreate方法（创建一个工作线程），多次onStartCommand方法（用于传入intent通过工作队列再发给onHandleIntent函数做处理）。

## 关于BroadcastReceiver ##
BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 进行操作或是 NotificationMananger 提醒用户。

### 注册 ###
#### 静态方式（AndroidManifest.xml里面） ####
```xml
< receiver android:name = ".MyBroadcastReceiver" >
 < intent-filter android:priority = "777" > //-1000-1000
<action android:name = "android.provider.Telephony.SMS_RECEIVED" />
</ intent-filter >
</ receiver >
```
#### 动态方式（代码里面） ####
```java
public class MainActivity extends Activity {
    MyBroadcastReceiver receiver;
    [@Override](/user/Override)
     protected void onResume() {
        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)
        receiver = new MyBroadcastReceiver();
        IntentFilter intentFilter = new IntentFilter( "android.provider.Telephony.SMS_RECEIVED" );
        registerReceiver( receiver , intentFilter);

        super.onResume();
    }
    [@Override](/user/Override)
    protected void onPause() {
        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)
        unregisterReceiver(receiver);
        super.onPause();
    }
}
```
#### 动态与静态的区别 ####
1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。

2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。动态注册的广播接收者将会导致应用报错而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。　

### 接收者 ###
```java
public class MyBroadcastReceiver extends BroadcastReceiver {

// action 名称
String SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED" ;

    public void onReceive(Context context, Intent intent) {

       if (intent.getAction().equals( SMS_RECEIVED )) {
           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。
       }
    }
}
```
### 发送广播的类型 ###
#### 普通广播 ####
所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。无法中断。
```java
Intent intent = new Intent("android.provider.Telephony.SMS_RECEIVED");
//通过intent传递少量数据
intent.putExtra("data", "finch");
// 发送普通广播
sendBroadcast(Intent);
```
#### 有序广播 ####

```java
//发送有序广播
 sendOrderedBroadcast(intent, null);
 ```
 在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。高级别的广播收到该广播后，可以决定把该广播是否截断掉.
 ```java
 public void onReceive(Context arg0, Intent intent) {
　　//获取上一个广播的bundle数据
　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle
　　bundle.putString("key", "777");
　　//将bundle数据放入广播中传给下一个广播接收者
　　setResultExtras(bundle);　
　　
　　//终止广播传给下一个广播接收者
　　abortBroadcast();
}
```
### 总结 ###
- 当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。
- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。
- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：

### Android 启动过程 ###
Android手机开机执行过程图：
![Android启动流程图](http://ovoxjpcrm.bkt.clouddn.com/a0c6b61c1b3235e5e218f3e5c2ca1142.png)
从开机到桌面的过程为：
**Bootloader ➪Kernel ➪Init进程 ➪ Zygote ➪ SystemServer ➪ ServiceManager ➪ Home Launcher**

Android服务包括系统服务和应用服务，系统服务是指Android系统在启动过程就已经启动实现了的服务，对于系统服务又分为Java服务和本地服务，Java服务是由Java代码编写而成，由SystemServer进程提供，而本地服务是由C/C++实现的服务，由Init进程在系统启动时启动的服务。应用服务是由开发者自行实现的某些特定服务。

1. Bootloader：
当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。
2. Kernel：Android内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。
3. init进程：nit进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。init始终是第一个进程。

      启动过程就是代码init.c中main函数执行过程：system\core\init\init.c在函数中执行了：文件夹建立，挂载，rc文件解析，属性设置，启动服务，执行动作，socket监听……
      rc文件解析

      .rc文件是Android使用的初始化脚本文件 ，Android中有特定的格式以及规则。
4. Zygote：所有的应用程序进程以及系统服务进程（SystemServer）都是由Zygote进程孕育（fork）出来的，zygote本身是Native应用程序，与驱动内核无关。

    我们知道，Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，也就是说，所有的进程都是直接或者间接地由init进程fork出来的。Zygote进程也不例外，它是在系统启动的过程，由init进程创建的（在系统启动脚本system/core/rootdir/init.rc文件中）。

    在Java中，不同的虚拟机实例会为不同的应用分配不同的内存。假如Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote是一个虚拟器进程，预加载以及初始化核心库类，让Dalvik虚拟机共享代码、降低内存占用和启动时间。

    Zygote进程包含两个主要模块：

    ①. Socket服务端，该Socket服务端用于接收启动新的Dalvik进程命令。

    ②. Framework共享类及共享资源，当Zygote进程启动后，会装载一些共享类和资源，共享类是在preload-classes文件中定义的，共享资源是在preload-resources文件中定义。因为其他Dalvik进程是由Zygote进程孵化出来的，因此只要Zygote装载好了这些类和资源后，新的Dalvik进程就不需要在装载这些类和资源了，它们共享Zygote进程的资源和类。

    Zygote启动分为两个阶段：

    ①. 虚拟机启动 --- 通过native启动　

    startVm(&mJavaVM, &env) 　　启动虚拟机　

    onVmCreated(env) 虚拟机启动后的初始化

    startReg(env) 注册JNI函数

    env->CallStaticVoidMethod(startClass, startMeth, strArray) 调用ZygoteInit类的main函数开创java世界　 　　　　　　　　　　　　

    ②. SystemServer进程 --- 通过Java启动

    registerZygoteSocket() 　为zygote进程注册监听socket

    preload() 加载常用的JAVA类和系统资源

    startSystemServer() 启动SystemServer进程

    runSelectLoopMode() 进入循环监听模式

    closeServerSocket() 进程退出时，关闭socket监听

5. 启动系统服务
Zygote创建新的进程去启动系统服务。你可以在ZygoteInit类的”startSystemServer”方法中找到源代码。

    核心服务：

    启动电源管理器；　

    创建Activity管理器；　

    启动电话注册；　

    启动包管理器；

    设置Activity管理服务为系统进程；

    启动上下文管理器；

    启动系统Context Providers；

    启动电池服务；

    启动定时管理器；

    启动传感服务；

    启动窗口管理器；

    启动蓝牙服务；

    启动挂载服务。

    其他服务：

6. 引导完成：一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。

## Android 自定义控件 ##

![view绘制流程](http://ovoxjpcrm.bkt.clouddn.com/43165c1825cf7773cf0fe35bc83dc308.png)
自定义控件的三种方式：
1. 继承已有的控件
>当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。

2. 继承一个布局文件
>一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。

3. 继承view
>通过onDraw方法来绘制出组件界面。

整个View树的绘图流程过程可简单概况为根据之前设置的状态

1.判断是否需要重新计算视图大小(measure)
2.是否重新需要安置视图的位置(layout)
3.以及是否需要重绘 (draw)，其框架过程如下：

> **1、mesarue()过程**
>
> 主要作用：为整个View树计算实际的大小，即设置实际的高(对应属性:mMeasuredHeight)和宽(对应属性:mMeasureWidth)，每个View 的控件的实际宽高都是由父视图和本身视图决定的。
>
> 具体的调用链如下： ViewRoot根对象的属性mView(其类型一般为ViewGroup类型)调用measure()方法去计算View树的大小，回调View/ViewGroup 对象的onMeasure()方法，该方法实现的功能如下：
>
> 1、设置本View 视图的最终大小，该功能的实现通过调用 setMeasuredDimension()方法去设置实际
> 的高(对应属性：mMeasuredHeight)和宽(对应属性：mMeasureWidth)。
>
> 2 、如果该View 对象是个ViewGroup类型，需要重写该onMeasure()方法，对其子视图进行遍历的
> measure() 过 程 。 对 每 个 子 视 图 的 measure() 过 程 ， 是 通 过 调 用 父 类 ViewGroup.java 类 里 的measureChildWithMargins()方法去实现，该方法内部只是简单地调用了 View 对象的measure()方法。
>
> **2、layout 布局过程**
>
> 主要作用：为将整个根据子视图的大小以及布局参数将 View树放到合适的位置上。具体的调用链如下：
>
> 1、layout 方法会设置该 View 视图位于父视图的坐标轴，即 mLeft，mTop，mLeft，mBottom(调用
> setFrame()函数去实现)接下来回调onLayout()方法(如果该View 是ViewGroup对象，需要实现该方法，对每个子视
> 图进行布局)。
>
> 2、如果该View 是个ViewGroup类型，需要遍历每个子视图 chiildView，调用该子视图的 layout()方法去设置它的坐标值。
>
> **3、draw()绘图过程**
>
> 由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View 树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View 类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。

自定义属性：
１．在布局文件中直接加入属性，在构造函数中去获得。
布局文件：
```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >
     <com.example.demo.myView
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         Text="[@string](/user/string)/hello_world"
         />
</RelativeLayout>
```
获取属性值：
```java
public myView(Context context, AttributeSet attrs) {
        super(context, attrs);
        // TODO Auto-generated constructor stub
int textId = attrs.getAttributeResourceValue(null, "Text", 0);
String text = context.getResources().getText(textId).toString();
    }
```

２．在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。

attrs.xml:
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="myView">
        <attr name="text" format="string"/>
        <attr name="textColor" format="color"/>
    </declare-styleable>
</resources>
```
使用：
```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:myview="http://schemas.android.com/apk/com.example.demo"
    >
     <com.example.demo.myView
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         myview:text = "test"
         myview:textColor ="#ff0000"
         />
</RelativeLayout>
```

获取属性值：
```java
public myView(Context context, AttributeSet attrs) {
        super(context, attrs);
        // TODO Auto-generated constructor stub
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView);
        String text = a.getString(R.styleable.myView_text);
        int textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE);

        a.recycle();
    }
```
## Android IPC ##
IPC是Inter-Process Communication的缩写，含义就是进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。

Android中的IPC方式：
原因：Android基于Linux，Linux的进程是相互独立的。为了保证安全性和独立性，一个进程不能直接操作和访问另一个进程空间。


1. 使用Bundler
>我们知道，四大组件中三大组件（activity、service、receiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输。

2. 使用文件共享
>共享文件也是一种不错的进程间通信方式，两个进程间通过读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程通过读取这个文件来获取数据。

3. 使用Messenger
>Messenger可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，实现Messenger有以下两个步骤，分为服务端进程和客户端进程。

4. 使用AIDL
>远程服务跨进程通信的一种方式。

5. 使用ContentProvider
>ContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式，它的底层实现同样也是Binder。

6. 使用Socket
>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。

## Android 5.0，6.0，7.0，JDK8 新特性 ##
5.0 ：

- 全新 Material Design 设计风格
- 支持多种设备（手机、平板电脑、笔记本电脑、智能电视、汽车、智能手表甚至是各种家用电子产品）
- 全新的通知中心设计（在锁屏界面也可以直接查看通知消息了，用户还可以直接在锁屏的情况下就行回复或进入应用。）
- 支持 64 位 ART 虚拟机 　
  >　　 新系统不仅在视觉效果上带来了巨大的变化，Android Lollipop 还在内部的性能上进行了飞跃。首先，新系统放弃了之前一直使用的 Dalvik 虚拟机，改用了 ART 模式，实现了真正的跨平台编译，在 ARM、X86、MIPS 等，无处不在。 　　ART 虚拟机编译器在内存占用及应用程序加载时间上进行了大幅提升，谷歌承诺所有性能都会比原来提升一倍。另外，对 64 位的支持也让 ART 虚拟机如鱼得水，开发者可以针对像 ARM Cortex-A57 这样的 64 位架构核心开发应用程序。Android Lollipop 支持更大的寄存器，支持新的指令集，提升了内存寻址空间，未来 Android 智能手机将支持 4GB 以上的内存。
- Project Volta 电池续航改进计划

  增加了 Battery Saver 模式，在低电量的时候系统会自动降低屏幕亮度、限制自动更换背景等功能。
- 全新的“最近应用程序”

  除了界面风格设计的改变之外，新的最近应用界面还借鉴了 Chrome 浏览器的理念，采用单独的标签展示方式。更重要的是，谷歌已经向开发者开放了 API，所以第三方开发人员可以利用这个改进为特定的应用增加全新的功能。
- 新的 API 支持，蓝牙 4.1、USB Audio、多人分享等其它特性

6.0:
1. 大量漂亮流畅的动画 安卓6.0系统增加了大量漂亮的过度动画，可以从视觉上减少卡顿感，给用户带来流畅的体验。

2. 相机新增专业模式 一直以来，原生的安卓相机都长被吐槽太过简单甚至简陋了，在此次的安卓6.0中，相机中新增了Pro专业模式，增加了快门速度调节和曝光度调节等新功能。

3. 全新的电源键菜单 一般来说，安卓的电源键菜单都是关机/重启/飞行，安卓6.0变成了关机/重启/紧急，关机和重启就不用赘述了，这个紧急模式是为了手机快没电的时候设计的，相当于飞行模式的高级版，可以关闭一切耗电应用，尽最大可能节省电量。

4. 可自定义锁界面样式 支持电话、信息、相机等快捷方式在锁屏界面的定制，用户可以根据自己的喜好调整这些图标的位置，或者开启或关闭这些快捷方式。

5. 全新的快速设置风格 不但是锁屏界面可以定制，安卓6.0还采用了全新的快速面板的色彩方案，用户可以通过更换主题换颜色。

6. 支持快速充电的切换 快速充电是手机厂商们的一大新发明，很多厂商都声称“充电X分钟，通话两小时”，这个功能虽然方便，但其实也有弊端，容易造成手机和电池发热。所以除非是在紧急情况下，一般不建议快速充电，安卓6.0原生支持关闭和开启快速充电功能。

7. 支持文件夹拖拽应用 可在应用从一个文件夹内直接拖到另一个文件夹，简化了此前繁琐的操作方式，拖拽的过程和Windows的拖拽功能有点相似。

8. 原生的应用权限管理 无需第三方应用和Root权限，原生的安卓6.0就支持应用权限管理，用户可以在安装应用时选择关闭一些应用权限，这一功能非常方便，再也不用担心流量偷跑和扣费了。

9. Now on Tap功能 “Now on Tap ”功能，是指将Google Now(一种语音助手)作为底层植入到安卓6.0系统中，用户只要只要双击home键启动Google Now，“这意味着用户随时都能启动搜索功能，目前暂时不知道这个功能进入国内会不会阉割掉。

10. 支持RAW格式照片 RAW格式的支持是众多拍照爱好者梦寐以求的， 然而绝大多数的安卓手机都没有或者剔除了这项功能。由于照片保存为jpg格式时或多或少都会损失一些画质，所以支持RAW格式是非常明智的。

7.0:
- 分屏多任务支持
- 画中画
- 通知栏快速回复
- OpenJDK替换Java API
- Android 7.0中采用了一项具有实时代码剖析功能的ARI JIT编译器，它能够在安卓应用程序在运行时不断提高自身的性能

JDK8：
- 1.Lambda表达式
- 2.Stream函数式操作流元素集合
- 3.接口新增：默认方法与静态方法
- 4.方法引用,与Lambda表达式联合使用
- 5.引入重复注解
- 6.类型注解
- 7.最新的Date/Time API (JSR 310)
- 8.新增base64加解密API
- 9.数组并行（parallel）操作
- 10.JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间

## Asset目录与res目录的区别 ##
- res/raw和assets的相同点：　

  两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。
- res/raw和assets的不同点：

  res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；

  assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。　

  res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹　

- 读取文件资源：　

  读取res/raw下的文件资源，通过以下方式获取输入流来进行写操作
  ```InputStream is =getResources().openRawResource(R.id.filename);  ```
  读取assets下的文件资源，通过以下方式获取输入流来进行写操作
  ```java
     /**
     * 从assets中读取图片
     */
    private Bitmap getImageFromAssetsFile(String fileName)
      {
          Bitmap image = null;
          AssetManager am = getResources().getAssets();
          try
          {
              InputStream is = am.open(fileName);
              image = BitmapFactory.decodeStream(is);
              is.close();
          }
          catch (IOException e)
          {
              e.printStackTrace();
          }
          return image;
      }

  ```
- 注意：

  Google的Android系统处理Assert有个bug，在AssertManager中不能处理单个超过1MB的文件，不然会报异常，raw没这个限制可以放个4MB的Mp3文件没问题。

  assets 文件夹是存放不进行编译加工的原生文件，即该文件夹里面的文件不会像 xml， java 文件被预编译，可以存放一些图片，html，js, css 等文件。

## JSON 和 XML 优缺点的比较 ##
- 1.在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。　
- 2.在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。　
- 3.在编码难度方面，XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。　
- 4.在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。　
- 5.在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous JavaScript and JSON)了。　
- 6.JSON和XML同样拥有丰富的解析手段。　
- 7.JSON相对于XML来讲，数据的体积小。
- 8.JSON与JavaScript的交互更加方便。
- 9.JSON对数据的描述性比XML较差。
- 10.JSON的速度要远远快于XML。

## ListView优化
重用了convertView，很大程度上的减少了内存的消耗。通过判断convertView是否为null，是的话就需要产生一个视图出来，然后给这个视图数据，最后将这个视图返回给底层，呈献给用户。

　　　每次在getVIew的时候，都需要重新的findViewById，重新找到控件，然后进行控件的赋值以及事件相应设置。这样其实在做重复的事情，因为的geiview中，其实包含有这些控件，而且这些控件的id还都是一样的，也就是其实只要在view中findViewById一次，后面无需要每次都要findViewById了。

　　通过线程来异步加载图片，把Http的相关操作放在线程里,最好使用线程池来控制线程数。返回的bitmap通过Handler来更新每个Item布局上的ImageView（就是赋上图片）。

　　当遇到大图片的话，可以对图片处理一下再使用，比如压缩，压缩到480*800。网上有很多关于图片压缩的资料。



## Android长连接，怎么处理心跳机制 ##
android系统的推送和iOS的推送有什么区别：

 首先我们必须知道，所有的推送功能必须有一个客户端和服务器的长连接，因为推送是由服务器主动向客户端发送消息，如果客户端和服务器之间不存在一个长连接那么服务器是无法来主动连接客户端的。因而推送功能都是基于长连接的基础是上的。 　　 　　IOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：
 - 在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况。　　
 - 省电，不会出现每个应用都各自维护一个自己的长连接。
 - 安全，只有在苹果注册的开发者才能够进行推送，等等。

android的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　 　 推送的实现方式：
- 一：客户端不断的查询服务器，检索新内容，也就是所谓的pull 或者轮询方式　
- 二：客户端和服务器之间维持一个TCP/IP长连接，服务器向客户端push　
- 三：服务器有新内容时，发送一条类似短信的信令给客户端，客户端收到后从服务器中下载新内容，也就是SMS的推送方式　


心跳包的机制，其实就是传统的长连接。或许有的人知道消息推送的机制，消息推送也是一种长连接 ，是将数据有服务器端推送到客户端这边从而改变传统的“拉”的请求方式。

安卓和客户端两个数据请求的方式:
- 1、push 这个也就是有服务器推送到客户端这边 现在有第三方技术 比如极光推送。
- 2、pull 这种方式就是客户端向服务器发送请求数据（http请求）

**原理：**
其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络了数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。

　　最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。

## 保证service不被杀死 ##
### 一、onStartCommand方法，返回START_STICKY ###
在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建 service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。

　　【结论】 手动返回START_STICKY，亲测当service因内存不足被kill，当内存又有的时候，service又被重新创建，比较不错，但是不能保证任何情况下都被重建，比如进程被干掉了....　

### 二、提升service优先级 ###
　　在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = "1000"这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。

### 三、提升service进程优先级 ###
　　Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:
- 1.前台进程( FOREGROUND_APP)
- 2.可视进程(VISIBLE_APP )
- 3.次要服务进程(SECONDARY_SERVER )
- 4.后台进程 (HIDDEN_APP)
- 5.内容供应节点(CONTENT_PROVIDER)
- 6.空进程(EMPTY_APP) 当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。

在onStartCommand方法内添加如下代码：
```java
Notification notification = new Notification(R.drawable.ic_launcher,
         getString(R.string.app_name), System.currentTimeMillis());

         PendingIntent pendingintent = PendingIntent.getActivity(this, 0,
         new Intent(this, AppMain.class), 0);
         notification.setLatestEventInfo(this, "uploadservice", "请保持程序在后台运行",
         pendingintent);
         startForeground(0x111, notification);
```

注意在onDestroy里还需要stopForeground(true)，运行时在下拉列表会看到自己的APP在： 【结论】如果在极度极度低内存的压力下，该service还是会被kill掉，并且不一定会restart

### 四、onDestroy方法里重启service ###
直接在onDestroy（）里startService 或 service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；

     【结论】当使用类似口口管家等第三方应用或是在setting里-应用-强制停止时，APP进程可能就直接被干掉了，onDestroy方法都进不来，所以还是无法保证~.~

### 五、监听系统广播判断Service状态 ###

　　通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。

### 六、将APK安装到/system/app，变身系统级应用 ###

# Java基础
## ArrayList、LinkedList、Vector的区别
- ArrayList 本质上是一个可改变大小的数组.当元素加入时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问.元素顺序存储 ,随机访问很快，删除非头尾元素慢，新增元素慢而且费资源 ,较适用于无频繁增删的情况 ,比数组效率低，如果不是需要可变数组，可考虑使用数组 ,非线程安全.

- LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList. 适用于 ：没有大规模的随机读取，大量的增加/删除操作.随机访问很慢，增删操作很快，不耗费多余资源 ,允许null元素,非线程安全.

- Vector （类似于ArrayList）但其是同步的，开销就比ArrayList要大。如果你的程序本身是线程安全的，那么使用ArrayList是更好的选择。 Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.

ps :Vector是同步的意思就是说它是线程安全的，不会有多线程问题。

## Excption与Error包结构
Throwable 类是 Java 语言中所有错误或异常的超类。 Java将可抛出(Throwable)的结构分为三种类型：

1. 错误(Error)
2. 运行时异常(RuntimeException)
3. 被检查的异常(Checked Exception)

Error是系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由Java虚拟机抛出的。

Exception它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。

## SOF问题（StackOverflow）
堆栈溢出原因：因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。
- 递归调用
- 大量循环或死循环
- 全局变量是否过多
- 数组、List、map数据过大

## OOM问题（outOfMemory）
原因：当内存占有量超过了虚拟机的分配的最大值时就会产生内存溢出（VM里面分配不出更多的page）。 　　 一般出现情况：加载的图片太多或图片过大时、分配特大的数组、内存相应资源过多没有来不及释放。

PS:以前最大16M，现在不知道了，而且不同的rom会做不同的修改。

解决办法：
1. 在内存引用上处理：适当时候软引用，内存不足会被gc掉。
2. 图片压缩
    ```java
    BimtapFactory.Option opts =  new   BitampFactory.Option();
            opts.inJustDecodeBounds =  true ;
            opts.inSampleSize=computeSample(opts, minSideLength, maxNumOfPixels);  // Android 提供了一种动态计算的方法 computeSampleSize
            opts.inJustDecodeBounds =  false ;
             try {
                    return  BitmapFactory.decodeFile(imageFile, opts);
            }  catch (OutOfMemoryError err){
    }
    ```
3. 图片缓存：三级缓存，lruCache + sd
4. 不用的对象设置成null，不用的图片直接recycle。
5. 慎用static，用static来修饰成员变量时，该变量就属于该类，而不是该类实例，它的生命周期是很长的。
6. 对于帧动画，可以加载一张，画一张，释放一张。

## 重写和重载的区别
重写：子类重写父类的方法，函数名，返回值，形参都不能改变。

重载：用一个方法的多种形似，比如构造方法就很多，只要求名字相同，别的不管。

## equals和==的区别
equals比较的是值，只要值一样就好。
== 比较的是对象，就算对象的值一样，但是他们在内存中的地址不一样，因为是两个对象。(对于基本数据类型，==比较的也是值)
```java
int a1=1; int a2=1; a1==a2：    true
Integer b1 =new Integer (1); Integer b2 =new Integer (1); b1==b2：    false
Integer b1 =new Integer (1); Integer b2 =new Integer (1); bi.equals(b2)：    true
```


## Java的数据类型
- 基本数据类型
数字类型：byte(8)、short(16)、int(32)、long(64)、float(32)、double(64)。
字符类型：char（16位Unicode字符）
布尔型：Boolean
- 引用数据类型：对象、数组。。。

## String、StringBuffer与StringBuilder
主要区别：
- String：字符串常量，效率不高（每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉）（在不怎么需要修改的时候使用）
- StringBuffer：字符串变量，效率高，线程安全。（在多线程的时候使用）
- StringBuilder：字符串变量，效率高，线程非安全。（在单线程使用）

## Java的四种引用：
- 默认强引用, A a = new A()，当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。所以用完以后记得a = null;
- 软引用SoftReference, 垃圾回收器会考虑回收, 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
SoftReference<String> str=new SoftReference<String>("xxx");
- 弱引用 WeakReference, 垃圾回收器更会考虑回收,一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
WeakReference<String> str= new WeakReference<String>("xxx");
- 虚引用PhantomReference, 垃圾回收器最优先回收,就是形同虚设，在任何时候都可能被垃圾回收器回收。

## wait()和sleep()的区别

sleep与wait最主要的区别在于，sleep与wait都可以使线程等待，但sleep不会释放资源而wait会释放资源。

还有就是，wait方法只能在同步块或者同步方法中执行。
```java
synchronized(x){
      x.notify()
     //或者wait()
   }
```
如果不懂：[http://www.cnblogs.com/hellocsl/p/3732733.html](http://www.cnblogs.com/hellocsl/p/3732733.html "sleepAndwait")

## smallPoint

1. 想要线程安全的hashMap：
    ```java
    Map map = Collections.synchronizedMap(new HashMap());
    ```
2. 从JDK7开始，switch可以支持String了。不支持Boolean
3. static：在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的。static修饰符表示静态的，在类加载时Jvm会把它放到方法区，被本类以及本类的所有实例所共用。在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间。如果一个被所有实例共用的方法被申明为static，那么就可以节省空间，不用每个实例初始化的时候都被分配到内存。

# android Piont
1. Intent 传递的数据类型:
>Serializable，charsequence, parcelable,Bundle.

2. 四大组件:
>activity,BroadcastReceiver,ContentProvider,Service

3. 四大布局:
>FrameLayout,LinerLayout,RelativeLayout,GridLayout



# 面经：
##  终止线程的三种方法 ##
1. 使用退出标志，使线程正常退出，也就是当**run方法完成**后线程终止。
2. 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。**thread.stop();**
3. 使用interrupt方法中断线程。
两种情况：
1.正常使用：while（！isInterrupted（））{……}来判断线程是否被中断。
2.线程处于阻塞状态，如使用了sleep方法。sleep方法将抛出一个InterruptedException

## list和set的区别 ##
- list:有顺序，数据可重复
- set：无顺序，不可重复

## hashMap的多线程问题 ##
hashmap是线程不安全的，多线程并发读写的时候就容易出现问题。数据错误甚至死循环。
解决方式：
- Collections.synchronizedMap将HashMap包装起来
>Map m = Collections.synchronizedMap(new HashMap());
- ConcurrentHashMap替换HashMap



## 屏幕适配 ##
图片：一个图片有l，h，xh，xxh等多个版本
布局：可以有多个版本的布局，layout_800*480等。
尺寸：多用dp少用px，px还可以转换为dp
权重：多使用权重。
百分比：PercenRelativeLayout，PercentLinerLayout等等。


## handler原理 ##
handler是线程间通信的工具，所有的界面操作都依赖于handler机制。
- 使用：
A线程创建一个handler，B线程用这handler去发送message，A线程在handerMessage方法里根据message的what和obj做想应的处理。
- 原理：
主线程跟子线程的区别就是在于主线程默认是调用了Looper的prepare和Looper的loop方法的。
prepare方法是创建一个轮循器，loop方法是让轮询器开始循环。
Looper中有一个成员变量叫做MessageQueue，是用来存放message的队列，任何修改在本线程中创建的UI的操作都会被放在消息队列中，loop它去循环这个消息队列，然后操作UI。
- 注意：
子线程也是也是可以创建和修改UI的，只是只能将UI创建在windowManage上，然后也只能修改自己创建的ui，想要修改主线程的Ui，则必须用到handler，试想如果随便一个线程都可以修改本线程的ui，那么就会UI混乱，带来线程安全问题。
  ```java
  Looper.prepare
  UI on window的代码
  Looper.loop
  ```

  主线程也是不可以修改子线程创建的ui的，还是要依靠handler


## 进程与线程 ##
- 进程是系统资源分配和调度的单位，线程是cpu的执行的基本单位
- 进程由系统控制，线程由程序员控制。
- 进程之间相互独立，要通信就涉及到IPC。
- 一个进程可以有多个线程。包含与被包含的关系。

在xml文件中的process属性可以指定进程。

## public protected default private
![控制符](http://ovoxjpcrm.bkt.clouddn.com/518a98d011e742f9e145a955e2550502.png)

递减

public（4） > protected（3） > default（2） > private（1）

本类 > 本包 > 子类 > 外部包


## java内存分配
引用类型：new出来的
A a = new A()
a叫做实例，不能叫对象，对象存放在堆中，实例存放在栈中，存的值是指向堆中对象的位置。

基本类型：int什么的，直接存放在栈中，存的就是变量的值。

![内存分配](http://ovoxjpcrm.bkt.clouddn.com/277bac1588614ffc8d7312b0a68732c5.png)

## 多线程的数据共享
1. 堆：堆是在进程空间中开辟出来的，理所当然的会被共享。
2. 全局变量：
3. 静态变量：
4. 文件等公共资源。

独享：
栈：


## listview复用问题及其解决办法
问题：item显示错乱

原因：
- 复用的时候有的数据没用进行设置，比如有一个String没用设置，那么这个String就显示的是之前那个item的String内容。

   解决：对每一个内容都要重新的设置。

- 由于滑动和显示是异步进行的，可能滑动的太快了，加载显示内容还没来得及完成，就显示的之前复用的内容，过会加载完了又变成显示正确的了。

   解决：设置一些tag，比如拿以前的url和现在的url比较。

# 数据结构

## 链表：

- 分为单链和双链，在内存中不连续，数组是连续的，数组要先确定大小。链表的大小可以改变。插入和删除比较容易。取数据比较麻烦。
- 循环链表：最后一个指向第一个。
- 时间复杂度：
    - 索引：O(n)（n步）
    - 查找：O(n)
    - 插入：O(1)（1步）
    - 删除：O(1)

## 栈：
- 先进后出，push压栈，pop出栈。
- 时间复杂度
  - 索引：O(n)
  - 查找：O(n)
  - 插入：O(1)
  - 删除：O(1)

## 队列：
- 先进先出
- 方法：
  - add：增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常
  - remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常
  - element  返回队列头部的元素如果队列为空，则抛出一个NoSuchElementException异常
  - offer  添加一个元素并返回true，如果队列已满，则返回false
  - poll    移除并返问队列头部的元素，如果队列为空，则返回null
  - peek  返回队列头部的元素，如果队列为空，则返回null
  - put 添加一个元素，如果队列满，则阻塞
  - take 移除并返回队列头部的元素，如果队列为空，则阻塞
- 时间复杂度
  - 索引：O(n)
  - 查找：O(n)
  - 插入：O(1)
  - 删除：O(1)
-     Queue<String> queue = new LinkedList<String>();


## 二叉树
二叉排序树：左<根<右（没有键值相等的节点）

- 广度优先遍历（一层一层遍历）：借助队列
  ```java
  public void BFtPrint(){
    LinkedList<Node> queue = new LinkedList<Node>() ;
    if(root!=null){
      queue.addFirst(root);                      //先把root节点从队列头加入。
      while(!queue.isEmpty()){
        Node node = queue.pollLast();          //从队列尾取出节点。
        System.out.print(node.data+",  ");//访问该节点。

  //若左右子树不为空，加入队列。注意顺序。
        if(node.left!=null){
          queue.addFirst(node.left);
        }
        if(node.right!=null){
          queue.addFirst(node.right);
        }
      }
    }
  }
  ```

- 先序遍历：根>左>右
- 中序遍历：左>根>右
- 后续遍历：左>右>根
- 时间复杂度
  - 索引：O(log(n))
  - 查找：O(log(n))
  - 插入：O(log(n))
  - 删除：O(log(n))
- 堆：堆是一种经过排序的树形数据结构,每个结点都有一个值。通常我们所说的堆的数据结构,是指二叉堆。

堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。

## 哈希

在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。
好处：不论哈希表中有多少数据，插入和删除（有时包括侧除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。哈希表不仅速度快，编程实现也相对容易。
缺点：哈希表也有一些缺点它是基于数组的，数组创建后难于扩展某些哈希表被基本填满时，性能下降得非常严重，所以程序虽必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。（hashmap有自己的扩容机制）

散列函数设计：
- 直接定址法：取关键字的某个线性函数值为散列地址：f(key) = a × key + b
- 除留余数法：f( key ) = key mod p ( p ≤ m ) m：散列表长度。

当key冲突时：
- 开放定址法：fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)，当有冲突时找下一个地址，下下个地址，直到找到一个非空的位置。
- 再哈希法：就是构造多个哈希函数，f1冲突就f2，再冲突就f3。。。
- 链地址法：将所有关键字为同义词的记录存储在一个单链表中
![链地址法](http://ovoxjpcrm.bkt.clouddn.com/bfe22901ddeb33e0dd220145301ad55d.png)

## 图
1. 邻接矩阵
 图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（邻接矩阵）存储图中的边或弧的信息。
  - 无向图：
  ![无向图](http://ovoxjpcrm.bkt.clouddn.com/300aa07cca1c6cfefa25c42ad14c5ca9.png)
  - 有向图：行->列
  ![有向图](http://ovoxjpcrm.bkt.clouddn.com/02d940773ac7f329c7561794961639c1.png)

2. 邻接表
图中顶点用一个一维数组存储，图中每个顶点vi的所有邻接点构成一个线性表
  - 无向表：
![无向表](http://ovoxjpcrm.bkt.clouddn.com/9818947f0d7255ebbfd5df02b2f7ddda.png)
  - 有向表
![有向表](http://ovoxjpcrm.bkt.clouddn.com/af560621c81b0397beb91e4e6a4baee7.png)  
3. 面向对象的七大设计原则  
- 原则一：单一职责原则又称单一功能原则   
  核心：高内聚，低耦合。  
- 原则二：开闭原则  
  核心：对扩展开放，对修改关闭。及在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。
- 原则三：里氏替换原则（LSP）  
  核心：1.在任何父类出现的地方都可以用他的子类来替代，子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。2.子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性  
  3.覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。4.覆盖或实现父类的方法时输出结果可以被缩小。  
  - 原则四：依赖倒转原则  
  核心：要依赖于抽象，不要依赖于具体的实现
- 原则五：接口分离原则  
  核心：不应该强迫客户程序依赖于他们不需要使用的方法。  
  接口分离原则的思想就是：一个接口不需要提供太多的行为，一个接口应只提供一个对外的功能，不应该把所有的操作都封装到一个接口中。  
  分离接口的两种实现方式：使用委托分离接口和使用多重继承分离接口  
- 原则六：合成复用原则  
  核心：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。  
   复用的种类：继承和合成聚合（在复用时优先考虑合成聚合）
  - 原则七：迪米特原则（又叫最少知识原则）
    核心：软件实体之间应该做到最少的交互。不要和陌生人说话。调用方只关心他需要使用的方法
  # Java面试  
1. 面向对象七大设计原则
- 单一职责原则    定义：一个类只负责一个领域的相应职责
- 开闭原则  定义：软件实体应对扩展开放，而对修改关闭
- 里氏替换原则  定义：所有引用基类的对象能够透明的使用其子类的对象
- 依赖倒转原则  定义：抽象不应该依赖于细节，细节依赖于抽象
- 接口隔离原则  定义：使用多个专门的接口，而不是使用单一总接口
- 合成复用原则  定义：尽量使用对象组合，而不是继承来达到复合目的
- 迪米特法则  定义：一个软件实体应当尽可能少的与其它实体发生相互作用  
2. 单例模式
 特点：单例模式只能有一个实例，单例模式必须自己创建自己的唯一实例，单例模式必须对给所有其他对象提供这一实例  
  单例模式的写法：懒汉式，饿汉式，登记式
- 懒汉式
为了考虑线程安全1.在getInstance方法上同步或者双重检查锁定
```
//懒汉式单例类.在第一次调用的时候实例化自己   
public class Singleton {  
    private Singleton() {}  
    private static Singleton single=null;  
    //静态工厂方法   
    public static synchronized Singleton getInstance() {  
         if (single == null) {   
             single = new Singleton();  
         }    
        return single;  
    }  
    //双重检查锁定
  //  public static Singleton getInstance() {  
    //    if (singleton == null) {    
      //      synchronized (Singleton.class) {    
        //       if (singleton == null) {    
          //        singleton = new Singleton();   
            //   }    
    //        }    
      //  }    
        //return singleton;   
    //}  
}  
```  
- 饿汉式  
  天生就是线程安全的
```
//饿汉式单例类.在类初始化时，已经自行实例化   
public class Singleton1 {  
    private Singleton1() {}  
    private static final Singleton1 single = new Singleton1();  
    //静态工厂方法   
    public static Singleton1 getInstance() {  
        return single;  
    }  
}  
```
- 懒汉式和饿汉式单例模式的区别   
  饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，
而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。  
 线程安全：饿汉式天生线程安全懒汉式本生是非线程安全的
 在资源性能方面，饿汉式在类创建的时候就已经存在一个实例，会占用一定的内存，但是初始化加载快，懒汉式正好相反。
 3. builder模式  
 定义：将一个复杂对象的构建与它表示分离，使得同样的构建过程创建不同的表示  
 使用场景：1.相同的方法，不同的执行顺序，产生不同的事件结果时2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。  
 优点  
 - 良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节
 - 建造者独立，容易扩展
 - 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到  
 缺点：
 - 会产生多余的Builder对象以及Director对象，消耗内存；
 - 对象的构建过程暴露
4. 原型模式  
定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。  
使用场景：1.类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗2.通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；
3. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。  
优点：
-   原型模式是在内存二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。  
缺点：
- 这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑  
5. 构造器Constructor是否可被override?  
构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload  
6. abstract class和interface有什么区别?  
含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方  法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract   class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象  静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。    
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中  的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。  
下面比较一下两者的语法区别：
- 抽象类可以有构造方法，接口中不能有构造方法。
- 抽象类中可以有普通成员变量，接口中没有普通成员变量
- 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
- 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
- 抽象类中可以包含静态方法，接口中不能包含静态方法
- 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
- 一个类可以实现多个接口，但只能继承一个抽象类。  
7.  类加载器  
- 类加载双亲委派机制  
  就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。   
![类加载器默认委派关系图](http://ovt2nfhfc.bkt.clouddn.com/0b3dffc443246100b10b0b6b97c1cb66.png)  
- 启动类加载器
- 标准扩展类加载器
- 系统类加载器
- 在不指定父类加载器的情况下，默认采用系统类加载器
- 编写自定义类加载器时，一般有哪些注意点  
  一般尽量不要覆写已有的loadClass(...)方法中的委派逻辑，正确设置父类加载器，保证findClass(String name)方法的逻辑正确性  
8. 类加载过程  
- 加载 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口，（2）链接 将java类的二进制代码合并到jvm的运行状态之中的过程
- 验证 确保加载的类信息符合jvm规范，没有安全方面的问题
- 准备 正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配
- 解析 虚拟机常量池内的符号引用替换为直接引用的过程。（比如String s ="aaa",转化为 s的地址指向“aaa”的地址）
- 初始化 初始化阶段是执行类构造器方法的过程。类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。  
9. 何时开始类的初始化  
（1）创建类的实例，（2）访问类的静态常量（除final）和类的静态方法（3）反射（4）当初始化一个类时，发现其父类还未初始化，则先父类的初始化（6）虚拟机启动时，先初始化main（）方法  
（1）子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化.  
（2）通过数组定义来引用类，不会触发类的初始化  
（3）访问类的常量，不会初始化类  

10. 垃圾回收机制  
开发人员不能直接在程序代码中清除内存  
新生代：绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失，主要用来存放新生的对象  
老年代： 对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多，主要用来存放应用程序中生命周期较长的内存对象  
永久代：也被称为方法区，用来保存类常量及字符串常量  
> 老年代要引用一个新生代的对象时，老年代中存在一个“card table”的512kb的块，所有老年代的对象指向新生代的引用都会被记录在这里。  

新生代又分为一个伊旬园（Eden）和两个幸存者空间（survivor）  
老年代的GC一般发生在空间满时。  
- 垃圾回收算法  
（1） 引用计数法 每个对象都有一计数器，当这个对象被引用了计数器加一，当某个实例生命周期抖了或者被赋予了新值，计数器减一，可以对计数器为0的对象回收。缺点：无法检测出循环引用  
（2）根搜索算法 从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。  
>可作为GC root对象的有（1）虚拟机栈中引用的对象（2）方法区中静态属性引用的对象（3）方法区中常量引用的对象（4）本地方法栈中引用的对象（Native对象）  

（3）标记清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收  
（4）标记-整理算法 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针  
（5）copying算法 该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面  
（6）分代算法 分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。

11. Java的四种引用方式   
第一是可以让程序员通过代码的方式决定某些对象的生命周期；  
第二是有利于JVM进行垃圾回收。
- 强引用 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。  
- 软引用 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。  
- 弱引用  弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象  
- 虚引用 在任何时候都可能被垃圾回收器回收，虚引用必须和引用队列关联使用  
12. Java中的多线程  
用多线程只有一个目的，那就是更好的利用cpu的资源，  
线程状态及其转换
创建，就绪，运行，阻塞，终止
![线程状态及转换](http://ovt2nfhfc.bkt.clouddn.com/1022d33c3732db384a18c06b4051bca2.png)   
13. lock和synchronized的区别  
（1）类型： lock为接口，有不同的实现类，synchronized为关键字  
（2） 锁的释放：lock需要手动释放锁，及unlock，synchronized不需要手动释放锁，当synchronized代码块执行完，自动释放锁  
（3）等待的中断：lock可以中断等待及 t.interrupt（），synchronized会导致线程无线中断，不可中断
（4）lock可以知道线程有没有成功获得锁，及trylock(),synchronized不能
- synchronized 为可重入锁
- ReentrantLock 可重入锁
- 公平锁：加锁前检查是否有排队等待的线程，先来先得 FIFO，即先排队，再尝试获取锁
- 读写锁 若读锁 被占用，则申请写锁的线程会等待，申请读锁的线程不用等待，若写锁 被占用，则申请写锁或读锁的线程都会等待  
14. Executors 提供四种线程池  
- newCachedThreadPool 是一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们  
- newSingleThreadExecutor 创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。  
- newFixedThreadPool 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。  
- ewScheduledThreadPool 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求
15. 线程的优先级
线程的优先级用setPriority()方法就行  
java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。  
每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。  
当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）  
当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程  
16. HTTP中get和post的区别  
GET一般用于获取/查询资源信息，而POST一般用于更新资源信息   
17. 反射机制  
一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中  
    它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编  
    译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如
    这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能
    的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功
    能。
       它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它
    满足我们的要求。这类操作总是慢于只直接执行相同的操作。
